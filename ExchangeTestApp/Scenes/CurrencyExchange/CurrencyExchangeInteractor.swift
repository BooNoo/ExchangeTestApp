//
//  CurrencyExchangeInteractor.swift
//  ExchangeTestApp
//
//  Created by Vladimir on 27.01.2021.
//  Copyright (c) 2021 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol CurrencyExchangeBusinessLogic
{
    func getNavigationTitle(request: CurrencyExchange.SetNavigationTitle.Request)
    func changeExchange(request: CurrencyExchange.ChangeExchange.Request)
    func fetchCurrencies(request: CurrencyExchange.FetchCurrencies.Request)
    func fetchCurrentCurrencyExchange(request: CurrencyExchange.FetchCurrentCurrencyExchange.Request)
    func countExchange(request: CurrencyExchange.CountExchange.Request)
}

protocol CurrencyExchangeDataStore
{
    var currencies: [Currency] { get set }
    var user: User? { get set }
}

class CurrencyExchangeInteractor: CurrencyExchangeDataStore
{
    var presenter: CurrencyExchangePresentationLogic?
    var worker: CurrencyExchangeWorker? = CurrencyExchangeWorker()
    var currencies: [Currency] = []
    var user: User?
    var exchangeFromIndex: Int = 0
    var exchangeToIndex: Int = 0
        
    func setTitle()
    {
        presenter?.setNavigationTitle(responce: CurrencyExchange.SetNavigationTitle.Response(from: currencies[exchangeFromIndex], to: currencies[exchangeToIndex]))
    }
    
    func updateIndexFromtoChange(_ context: CurrencyExchange.ExchangeContext)
    {
        setTitle()
        fetchCurrentCurrencyExchange(context)
    }
    
    func fetchCurrentCurrencyExchange(_ context: CurrencyExchange.ExchangeContext)
    {
        let response = CurrencyExchange.FetchCurrentCurrencyExchange.Response(exchangeFromIndex: exchangeFromIndex, exchangeToIndex: exchangeToIndex, exchangeFrom: currencies[exchangeFromIndex], exchangeTo: currencies[exchangeToIndex], context: context)
        presenter?.presentCurrentCurrencyExchange(response: response)
    }
    
    func getExchangeValue(from: Currency, to: Currency) -> Float
    {
        return to.value / from.value
    }
}

extension CurrencyExchangeInteractor: CurrencyExchangeBusinessLogic
{
    func countExchange(request: CurrencyExchange.CountExchange.Request)
    {
        guard let text = request.text else { return }
        let value = Float(text)
        var fromToValue: Float?
        var toFromValue: Float?
        if let value = value {
            switch request.context {
            case .From:
                toFromValue = value * getExchangeValue(from: currencies[exchangeFromIndex], to: currencies[exchangeToIndex])
            case .To:
                fromToValue = value * getExchangeValue(from: currencies[exchangeToIndex], to: currencies[exchangeFromIndex])
            }
        }
        presenter?.presentCountExchange(response: CurrencyExchange.CountExchange.Response(exchangeFromIndex: exchangeFromIndex, exchangeToIndex: exchangeToIndex, exchangeFromToValue: fromToValue, exchangeToFromValue: toFromValue, context: request.context))
    }
    
    func fetchCurrentCurrencyExchange(request: CurrencyExchange.FetchCurrentCurrencyExchange.Request)
    {
        fetchCurrentCurrencyExchange(.From)
    }
    
    func changeExchange(request: CurrencyExchange.ChangeExchange.Request)
    {
        switch request.context {
        case .From:
            exchangeFromIndex = request.index
        case .To:
            exchangeToIndex = request.index
        }
        updateIndexFromtoChange(request.context)
    }
    
    func fetchCurrencies(request: CurrencyExchange.FetchCurrencies.Request)
    {
        fetchUser()
        let queue = DispatchQueue.global(qos: .userInitiated)
        queue.async { [weak self] in
            guard let self = self else { return }
//            Thread.sleep(until: Date().addingTimeInterval(3))
            self.worker?.fetchCurrencies(completionHandler: { (currencies) in
                DispatchQueue.main.async {
                    self.currencies = currencies
                    self.presenter?.presentFetchedCurrencies(response: CurrencyExchange.FetchCurrencies.Response(currencies: self.currencies))
                    self.fetchUser()
                    self.refillUserWallet(currencyCode: "USD", value: 20)
                    self.refillUserWallet(currencyCode: "USD", value: -20.12)
                }
            })
        }
    }
    
    func fetchUser()
    {
        let queue = DispatchQueue.global(qos: .userInitiated)
        queue.async { [weak self] in
            guard let self = self else { return }
//            Thread.sleep(until: Date().addingTimeInterval(3))
            self.worker?.fetchUser(completionHandler: { (user) in
                DispatchQueue.main.async {
                    self.user = user
                    print(self.user)
                }
            })
        }
    }
    
    func refillUserWallet(currencyCode: String, value: Float)
    {
        let queue = DispatchQueue.global(qos: .userInitiated)
        queue.async { [weak self] in
            guard let self = self else { return }
//            Thread.sleep(until: Date().addingTimeInterval(3))
            self.worker?.refillUserWallet(currencyCode: currencyCode, value: value, completionHandler: { (user) in
                DispatchQueue.main.async {
                    self.user = user
                    print(self.user)
                }
            })
        }
    }
    
    func getNavigationTitle(request: CurrencyExchange.SetNavigationTitle.Request)
    {
        setTitle()
    }
}
